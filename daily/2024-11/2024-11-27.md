
:open_book:教材：[パーフェクトRuby on Rails【増補改訂版】](https://gihyo.jp/book/2020/978-4-297-11462-6)

6-7から。イベント参加機能の作成。  
イベント参加用モデルとコントローラーの作成。  
ユーザーのイベント参加を管理するために、中間テーブルとしてTicketモデルを作成。  
後々退会機能を実装する際にnullを保存できるようにするために、user_idカラムにはnullを許可。  
ユーザーがイベントに重複して参加できないようにするためにユニークインデックスを追加。  
モデルのリレーションにも`optional: true`を追加して関連先がなくてもバリデーションエラーにならないようにする。  
コメントのバリデーションは３０文字以内、空文字やnilを許可。  
User、Eventモデルにhas_manyを追加。  
ビューファイルとルーティングの修正。  
イベント詳細ページに参加するボタンを追加。  
参加するボタンを押したときにコメント入力用のモーダルウィンドウが表示されるようにする。  
`#createTicketErrors`を用意してバリデーションエラーメッセージを表示できるようにする。  
ログイン状態と未ログイン状態で参加するボタンの処理を分けるので、表示も別にする。  
イベント参加を表すTcketはEventのリソースと親子関係にあるのでresourcesをネストしてリソースの親子関係をルーティングで表す。  

イベント参加処理の作成  
未ログイン状態で参加するボタンを押したときにnewアクションを実行されるようにし、newアクション内では`ActionController::RutingError`をriseするようにする。  
ログイン状態で参加するボタンを押して、モーダルウィンドウでコメントを送信するとcreateアクションが実行されるようにする。  
失敗時のエラーはSJRで表示するので`#createTicketErrors`に対応したJSファイルの作成。  
エラーメッセージを日本語化。  

参加者一覧表示機能の作成  
GitHubURLをDRYにするため`url_for_github`メソッドをApplicationHelperに定義。  
eventコントローラーのshowメソッドにticketsオブジェクト群を代入して表示するように定義。  
includesを使用してN+1を回避。  
ビューファイルを修正し、参加者一覧が表示されるように変更。  

参加キャンセル機能の作成  
ticketオブジェクトがある場合は参加するボタンの代わりに参加をキャンセルするボタンが表示されるようにする。  
EventControllerのshowアクションに閲覧しているイベントへの参加状況をticketに格納する処理を追加。  
TcketsControllerに参加キャンセル処理であるdestroyアクションを追加。  
find_by!を使用して存在しないebent_idが渡されたときに`ActiveRecord::NotFoundError`を発生させて４０４画面を表示させるように記述。  
必ずリダイレクトするアクションで、ビューにインスタンス変数を渡す必要がないためインスタンス変数は利用しない。  
eventモデルのhas_manyを修正してイベントが削除された段階で関連するTcketsも削除するように変更。  

6-8 退会機能  
退会用のコントローラーとビュー、ルーティングの作成  
retirementsコントローラーを作成。  
app/views/layouts/application.html/hamlを編集して、ログイン状態の時にヘッダーに「退会」リンクを表示させる。  
退会確認ページになるapp/views/retirements/new.html.hamlを作成、編集。  
退会するリンクには`method: :post`を追加して、HTTPのPOSTメソッドとしてリクエストを送信するようにする。  
本来、退会などの重要な処理は、実行前に再度パスワードを入力させるなどして悪意のある第三者による操作を妨げるものだが、今回はGitHubログインを採用しているため処理が複雑になるので省略しているとのこと。  
ルーティングには単数形のリソースで設定。  
退会処理はユーザの錯書を行っているので、UsersControllerのdestroyアクションで退会処理を行ってもいいが、退会の確認ページのためのアクションを新しく作らなければならなくなる。  
基本の7つのアクション（`index`、`new`、`create`、`show`、`edit`、`update`、`destroy`）以外のアクションをコントローラーに追加していくと、プロジェクトが進むにつれて一つのコントローラーにアクションが増えすぎてしまってコントローラーの見通しが悪くなる。  
これを避けるために、基本の7つのアクション以外のアクションを作成したくなったら別のコントローラーを作るという指針がある。  

退会処理の作成  
RetirementsControllerにnewアクションとcreateアクションを追加。  
createアクションが実行された際にユーザーレコードの削除に成功したらログアウトしたときと同じようにセッションを削除する。  
Userモデル削除時に実行されるコールバックを追加し、ユーザー削除に対応するように関連を修正。  
削除するユーザの作成したイベントの終了日時と参加表明したイベントの終了日時を調べて、終了していないものがあればエラーメッセージを返す`check_all_events_finished`を定義し、before_destroyに記述し削除時に`check_all_events_finished`が呼び出されるように設定。  
has_manyに`dependent: :nullify`オプションを追加して削除したときに関連するレコードの外部キーをnullにできるようにする。  
ユーザが参加しているイベントを調べるために`participating_events`という名前の関連を定義。  
SJRでバリデーションエラーの実装。  
イベント詳細ページのビューを編集し、イベントのowner_idがnullの時に「退会したユーザです」と表示するように修正。  

6章終了。

### Railsアプリケーションのテスト

7章突入。6章以降は全部サンプルで開発してるイベント作成アプリ上でやるのか…。

#### テストコードをどう書いていくか

Railsアプリケーションを作るときには、テストも一緒に書いていくのが一般的。  
テストを書くことで、
- 対象アプリケーションの仕様及び設計について考えが深まり、プロダクトコーデへフィードバックされる
- テスト駆動開発と呼ばれる手法で開発を推進させる
- 手作業によるテストを減らせる
- 想定通りに動くかという不安を減らせる
- リファクタリングや仕様の変更に自信をもって対応できる

という恩恵がある。

rails newして作り始めたアプリケーションを実装するときには、各機能を実装するごとにテストコードも書いていく。  
小さい機能ごとにテストを書いたほうが、考慮する範囲を小さくできるし、バグも早く発見したほうが修正コストも安くなる。  
また、テストを書いて動かしてみることで、設計上の問題、使用の問題に気づける。  
テスト駆動開発はテストからフィードバックを得て開発を促進させる手法。  
テスト駆動開発は、「テストを書く → 実装を書く → リファクタリングをする」というサイクルを繰り返し行う。  
テストを最初に書くことをテストファーストと呼ぶ。  
テストを各工程で、どのような設計にするかを考え、テストを書いた後にテストをどうやったらパスするかを考えて実装を書く。  
その後、同修正したらきれいなコードになるかを考えてリファクタリングを行う。  
各段階でのやるべきことに専念できるので、一度にきれいで正しいコードを書こうとするのに比べて考えなければいけないことを減らせる。  
また、テストを書くことで仕様の細部まで考慮されるので、そこからフィードバックを得て設計や実装をブラッシュアップすることもできる。  

一般的には、モデルに対するテストとE2Eテストを書いていくのがおすすめ。  
E2Eテストとしてブラウザから操作する機能ではシステムテストを、API機能ではコントローラの機能テストとインテグレーションテストを利用する。  
、また、Railsの各機能は専用のテストを用意していることが多いので、併せて各機能に対するテストを書く。  

テストのないRailsアプリケーションに対してテストを書くときには、E2Eテストであるシステムテストから書き始める。  
システムテストから書き始めると
- 外からみたアプリケーションの動作がわかればテストを書けるので、概要をつかんだ段階でテストを書き始めることができる
- routes、コントローラー、モデル、ビューのすべてを通るので、テストカバレッジを効率よく広げられる
- テストを書いてアプリケーションの仕様を確かめることができるので、アプリケーションに対する理解を深めることができる

という利点があるが、一方でシステムテストだけでカバーしようとすると、
- テスト実行時にブラウザを使うことから、実行速度が遅くなる
- アプリケーション全体の動作のテストはできるが、部品ごとの仕様はわからず、それぞれが正しくうがいているかの確認ができない

という問題がある。  
なので、システムテストで広範囲にテストを書いてから、足りない部分を各種テストを使って埋めていくと効率がいい。  

#### minitest　と　RSpec

minitestはシンプルなテストフレームワークでRuby1.9からRubyの標準ライブラリに組み込まれた。  
Railsもデフォルトではminitestを使う。  
minitestはxUnit風な書き方と、RSpec風な書き方をサポートしているが、RailsではデフォルトでxUnit風の書き方のみサポートしている。  
xUnit風の書き方ではテストコードとしてクラスやメソッドを定義する。  
RSpec風の書き方ではdescriptメソッドやitメソッドなど専用のDSLを利用してテストを記述する。  
minitestは基本的なテスト用の機能やモック機能などを持っている。  
また、Railsが独自で拡張しているカスタムアサーションなどのヘルパーメソッドやActionMailerなどの各機能を値要したコードをテストするのに便利なヘルパーなども提供している。  
Rails6.0からはテスト実行を高速化する並列実行を行えるようになった。  
RSpecはRailsアプリケーション開発に利用するテストフレームワークのデファクトスタンダートと言えるライブラリ。  

minitestはRailsに出後ると出添付されているテストフレームであることが強みであり、Rails6.0で導入された並列実行のように、新機能に対して最初に対応されるメリットがある。  
また、新機能が出たときにテストヘルパー及びカスタムアサーションが併せて提供されることが多いので、新機能を導入するときにすでにテスト環境が整った状態になっている。  
Railsガイドでもminitestをつかった説明が書かれ、テストヘルパーにどんなメソッドがあるかを調べるのにもRails公式のAPIリファレンスマニュアルを利用できる。  
RSpecは大きなシェアを持っていることが強み。  
RSpecを導入しているプロジェクトは多く、RSpecを書いた経験がある人も多い。  
ドキュメントも、公式のものに加えてWeb上で実際に使って得られたノウハウを解説する多くの記事がある。  
また、テストコードに構造化の道具が用意されている。  
どちらを選んでもテストコードの読みやすさは変わりなく、基礎的なアサーション昨日はどちらも充実しているので、違いはほとんどない。  
RSpecは豊富な書き方を提供しているといえるし、minitestはシンプルに保つことをよしとしている。  
7章ではminitestを使う。RSpecについての参考資料は[Everyday Rails - RSpecによるRailsテスト入門](https://leanpub.com/everydayrailsrspec-jp/)に詳しい解説が載っている。

7-3からfactory_botの導入。  
テキスト通りにバージョン指定なしでfactory_bot_railsを導入すると最新バージョンが入ってきてしまうので、[サンプルリポジトリ](https://github.com/perfect-ruby-on-rails/awesome_events/tree/master)に合わせて  
```
gem 'factory_bot_rails', '6.0.0'
```
でバージョン指定する。
こうしないと、ruby2.6.6、rails6.0.3環境でfactory_botの定義ファイルを生成しようとするとsyntax errorがでてしまう。
