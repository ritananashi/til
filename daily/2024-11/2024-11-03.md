
:open_book:教材：[パーフェクトRuby on Rails【増補改訂版】](https://gihyo.jp/book/2020/978-4-297-11462-6)

4-4-5は著者の用意したStimulusのサンプルコードの解説だったのでまとめはなし。
4章読了。５章から。

### Active Jobによる非同期実行

Rails4.2より、非同期実行処理機能を提供するActive Jobというライブラリが追加された。    
Active Jobを使うことで、バックエンド上で実行する非同期処理を統一的に利用できる。  

ジョブクラスは原則としてApplicationJobを継承するようにする。  
ApplicationJobはモデルにおけるApplicetionRecordと同じ位置づけのクラス。app/jobs/application_job.rbに書かれている。  
Active Jobはアダプターを使ってバックエンドを切り替えることができて、デフォルトではasyneがアダプターとして設定されている。  
asyncアダプターはRailsプロセス中のスレッドプールでジョブを実行するので、追加で何かをインストールすることなくジョブを非同期実行できるが、プロセスを再起動するとキュー中のジョブは失われる。  
コンソールで`生成したジョブクラス名.perform_later`と入力すると、バックエンドキューにジョブを追加して非同期実行する。  
`perform_later`に引数を渡すと、ジョブクラスのpreformメソッドに定義された引数を利用できる。  
`生成したジョブクラス名.set(wait: 1.minute).preform_later`で1分後に実行するジョブを追加できる。  
`wait_until`だと実行日時を指定できる。  
`preform_later`のかわりに`preform_new`を使うとその場で同期的に実行する。  
他にもいろいろな引数があるが、アダプターによっては指定できないオプションもある。  

Active Jobではジョブをキューへ保存及びキューから読み出すとき、自動でシリアライズとデシリアライズの処理が行われているので、ジョブはすべてのオブジェクトを引数として受け取れるわけではない。  
基本型、Symbol、日時を扱う型、Hash、Array、Active Recordオブシェクトがジョブとして渡せるオブジェクト。  
参考：[シリアライズ](https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA)  
参考：[デシリアライズ 【deserialize】 デシリアライゼーション](https://e-words.jp/w/%E3%83%87%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA.html)  
Active Recordオブジェクトもデフォルトでジョブへ渡すことができて、シリアライズ、デシリアライズの処理にはGlobal IDライブラリが使われている。  
キューへ追加するときのシリアライズ処理では、Global IDを使ってモデルオブジェクトの情報をURI文字列へ変換 → キューへ保存のながれ。  
Active Recordオブジェクトには変換処理を行うためのto_global_idメソッドが追加されている。  
キューから取り出すときは、キューに保存していたURI文字列からGlobalID::Locatorを使ってモデルオブジェクトに復元するが、この時にモデルクラスのfind(id)メソッドを実行するので、ジョブが実行されたときのDBレコードの状態で実行されることになる。  

asyncアダプターは開発時には便利だが、プロセスの再起動時にジョブが失われるのでproduction環境で運用するには向いていない。  
Active Jobには、バックエンドとつなぐアダプターとしてSidekiq、Resque、Delayed Jobなどが用意されていて、Active Jobで非同期処理を実装しておくと、これらのバックエンドを設定で切り替えられる。  

:open_book:教材：[駆け出しエンジニアのためのDocker入門](https://www.udemy.com/course/docker-startup/?couponCode=PLOYALTY0923)

### COPYとADDコマンド

どちらもファイルをイメージに追加する命令。  
ADDはネット経由からもファイルをダウンロードできたり、tar/zipみたいな圧縮ファイルでも追加できる。  
Docker公式はCOPYを推奨しているので、ADDよりCOPYを使った方がいい。  
昨日が絞られていた方が間違いがないし、基本的にホストのファイルを追加するだけで十分なことができる。  
```Dockerfile
COPY ホストのファイル コンテナのパス
# docker buildでホストのファイルが指定したコンテナのパスの中に入る。
```
COPYの使いどころ
- イメージにプログラムのソースコードを入れたいとき
- 設定ファイルをあらかじめソフトのほうに入れておいて、設定ファイルが反映された状態でイメージを作りたいとき
