
:open_book:教材：[パーフェクトRuby on Rails【増補改訂版】](https://gihyo.jp/book/2020/978-4-297-11462-6)

3-4-4まで読了。出かけてたのであまり読めなかった。

### 秘密情報の管理  
Railsでは以前から設定値や秘密の文字列を取り扱う方法を用意しているが、現実に即したものへのバージョンアップを繰り返した結果、Rails5.1時点では複数の取り扱い方法が存在することになり、一見するとどれをどのように使えばいいかわかりにくくなってしまった。  
Rails5.2でこれらの機能を統合したcredentialsと呼ばれる機能を作成。Rails6.0でより拡張された。

Rails4.0までは秘密の文字列を安全に管理する標準的な方法はなかった。  
秘密の文字列としてCookieの暗号化を行うときに利用するトークン存在していたが、config/initializer/secret_token.rbに平文で記載されていた(!?)。  
なので、秘密の文字列を扱う時は各自で工夫する必要があった。  
12 fact appの考え方が広まるにつれて秘密の文字列は環境変数経由で利用することが一般的になった。  

Rails4.1からはsecrets.ymlが登場。  
rails newをした時点でconfig/secrets.ymlが生成されるようになった。  
この機能が導入され、config/secrets.ymlで秘密の文字列利用するという方針がRailsから提示された。  
しかし、config/secrets.ymlの内容では平文のままで、かつ本番環境では環境変数経由でアクセスするようになっており、環境変数をどのように取り扱うかは以前までと同じ問題を抱えていた。

Rails5.1でconfig/secrets.ymlの抱えていた問題を解消するために、encrypted secretsを使った暗号化が提示された。  
config/secrets.yml.encというファイルに暗号化した内容を記載することで、こよファイル自体をアプリケーションと同じリポジトリに含めることができるようになった(それまではデプロイ時に別リポジトリから参照する手法などがあった)。  
環境変数経由で渡すRAILS_MASTER_KEYという値のみを別で管理すれば良くなったので、管理コストが大きく下がった。  
config/secrets.yml.encはrails newを行なっても作成されないので、`railr secret:setup`で生成する。  
config/secrets.yml.encは暗号化されており直接編集できないので、`bin/rails secrets:edit`で編集する。  
開発環境で使う時はconfig/environments/development.rbに`config.read_encrypted_secrets = true`を記載する必要がある。  
これでRailsの仕組みでトークンなどを暗号化して安全に使えるようになった。

:open_book:教材：[駆け出しエンジニアのためのDocker入門](https://www.udemy.com/course/docker-startup/?couponCode=PLOYALTY0923) 

### コンテナボリューム

Dockerで一番迷う部分がボリュームの永続化。  
コンテナ内のボリュームは消えてしまうので、データベースなどの永続データには使えない。  
仮想環境だとディスクの上にいるので、データはディスクに書き込まれるため、永続化は常にされているが、Dockerコンテナはメモリ上にいるので、コンテナが削除されてしまうとコンテナ内のボリュームも一緒に削除されてしまう。  
ボリューム共有でコンテナでも永続データベースが作れる。  
コンテナを消すとデータベースも消えてしまうが、ホストとボリュームの共有を行うことで、データを永続化できる。  
ホストのディレクトリとコンテナのディレクトリを共有するやり方があり、共有するとデータベースに書き込みがあったときにホスト側のディスクにも書き込まれるようになる。  
コンテナが壊れて新しいコンテナをDockerイメージから立ち上げなおしても、ホスト側のディレクトリと共有しておくことで、ホスト側の永続データをまた使うことができる。
