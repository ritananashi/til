📖[プロを目指す人のためのRuby入門［改訂2版］ 言語仕様からテスト駆動開発・デバッグ技法まで](https://gihyo.jp/book/2021/978-4-297-12437-3)

※3/16～4/2　スクールの卒業制作をやっていたので読書はお休み
※MVPリリースのLGTMが出るまで読書

### Procオブジェクトについてもっと詳しく

- Procオブジェクトを実行する様々な方法  
  `Proc`オブジェクトを呼び出すときは、`call`メソッド以外にも`yield`メソッドや`.()`、`[]`、`===`を使って呼び出せる。  
  `case`文の`when`節で`Proc`を使えるようにするため、`===`でも呼び出せるようになっている。
  （`when`は内部的に`===`をやっている）

- `&`と`to_proc`メソッド  
  `Proc`オブジェクトをブロックとして渡すときは、引数の前に`&`をつけるが、この時厳密には右辺のオブジェクトに対して`to_proc`メソッドを呼び出して、戻り値として得られた`Proc`オブジェクトをブロックを利用するメソッドに与えている。  
  シンボルから`Proc`オブジェクトを作成するときは、`&:シンボル`のようになる（もちろん`to_proc`メソッドでも`Proc`オブジェクトにできる）。  
  `Proc`オブジェクトに第一引数を渡すと、第一引数をレシーバにして、レシーバに対して元のシンボルと同じ名前のメソッドを呼び出す。  
  第二引数以降が、シンボルで指定したメソッドの第一引数になる。  
  `map`メソッド等のブロックを簡潔に書くときの`&:メソッド`は**シンボルに対して`to_proc`メソッドを呼び出して、`Proc`オブシェクトに変換されたメソッドをブロックとして渡している**
  例えば、Paizaとかでよく使う`gets.split.map(&:to_i)`は
  1. `:to_i`に対して`to_proc`を呼び出して`Proc`オブジェクトに変換
  2. `Proc`オブジェクトに変換された`:to_i`を`map`メソッドにブロックとして渡す
  3. `Proc`オブジェクトとなった`to_i`は`map`メソッドから配列の各要素を実行時の第一引数として受け取る。  
  第一引数は`Proc`オブジェクトのレシーバになるので、配列の各要素に対して`to_i`メソッドを呼び出す。
  1. `Proc`オブジェクトの戻り値を新しい配列に詰め込む
  2. 配列の各要素が変換された新しい配列が`map`メソッドの戻り値になる  
  
  という動きになる。

- Procオブジェクトとクロージャ  
  `Proc`オブジェクト内でローカル変数や引数を参照すると、メソッドの実行が完了しても`Proc`オブジェクトは引数やローカル変数にアクセスし続けられる。  
  なので、メソッドの実行が終わっても、`Proc`オブジェクトを実行するとメソッド内の変数の値などを変更することが出来てします。  
  - クロージャ（closure、関数閉包）  
    生成時のコンテキスト（変数情報など）を保持している関数のこと  
    Rubyのブロックや`Proc`はクロージャとしてふるまう。

11章。パターンマッチについての章。ハンズオンはJSON形式のログデータを特定の書式の文字列に変換するログフォーマッタープログラム。

### パターンマッチの基本

パターンマッチは以下の様な構文になっている。
```ruby
case 式
in パターン1
  パターン1にマッチしたときの処理
in パターン2
  パターン2にマッチしたときの処理
else
  どのパターンにもマッチしなかったときの処理
end
```
パターンマッチでは`in`節にローカル変数を宣言する。代入演算子を使わずに、`in`節に変数を書くだけで宣言と代入が行われる。  

- ハッシュをパターンマッチさせる  
  ハッシュをパターンマッチさせるときは、`in`節に`{キー:}`のような形で指定する。  
  値を省略してキーのみを書いたときは、自動的にキーと同じ名前のローカル変数が作成される。  

### パターンマッチの利用パターン

- valueパターン  
  `in`節に数値や文字列などを直接指定できる利用パターン。  
  `case`節の式と`in`節の値が等しければ処理が実行される。  
  パターンが一つもマッチしなかったらエラーが発生する。  
  `else`節を用意すれば一つもマッチしなかったときの処理を書くことができる。  
  `else`節の代わりにvariableパターンを利用して、任意のオブジェクトにマッチする`in`節を用意することで例外の発生を防止できる。  
  `in節のオブジェクト === case節のオブジェクト`の結果を評価している。  

- variableパターン  
  `in`節のパターンに変数を書いてローカル変数の宣言と代入を同時に行う利用パターン。  
  ```ruby
  case 式
  in 変数
    処理
  end
  ```
  こう書くとあらゆるオブジェクトがマッチして変数に代入される。  
  `in`節で事前に定義された変数の値を参照したいときは、ピン演算子（`^`）を使う。  
  ```ruby
  alice = 'Alice'
  bob = 'Bob'
  name = 'Bob'

  case name
  in ^alice
    'HEllo Alice'
  in ^bob
    'Hello Bob'
  end
  ```
  ピン演算子を使えば、`in`節で代入された変数を同じ`in`節で参照することもできる。  
  厳密にいうとピン演算子を使ったマッチはvalueパターンになるので、マッチには`===`が使われている、。  
  `in`節に指定できる変数はローカル変数のみなので、インスタンス変数を使おうとすると構文エラーになる。  
  ピン演算子を使うときもローカル変数のみ使える。  
  メソッド呼び出しもピン演算子と組み合わせることはできない。

- arrayパターン  
  `in`節に`[]`を使って配列の構造パターンを指定する利用パターン。  
  `[]`に書いた変数には対応する要素の値が代入される。  
  配列は入れ子になってても使える。  
  ```ruby
  case [1, [2. 3]]
  in [a, b]
    "a=#{a} b=#{b}"
  end
  #=> a=1 b=[2, 3]

  case [1, [2. 3]]
  in [a, [b, c]]
    "a=#{a} b=#{b} c=#{c}"
  end
  #=> a=1 b=2 c=3
  ```
  変数じゃなく数値や文字列をそのまま`in`節に指定すると、その値と等しいことがマッチの条件になる。  
  マッチの判定には`===`が使われるので、クラス名や範囲オブジェクトを`in`節に指定して、そのクラスのインスタンスであるかや、範囲に収まる値であるかといった条件を指定できる。  
  `in`節で同じ変数を2回以上使うことはできない。が、`_`か`_`で始まる変数は任意の要素を表現する目的で、例外的に２回以上使うことができる。  
  `in`節で`*`を使うと任意の長さの要素を指定したことになる。これは、最後の要素以外にも再著や途中でも使える。  
  `*`を使いたいけど変数には入れなくていいときは、`*`のみ書けばいい。`,`で終わらせても同じ意味になる。  
  一番外側の`[]`は省略できる。  

- hashパターン  
  `in`節に`{}`を使ってハッシュの構造パターンを指定する利用パターン。  
  値に変数を指定すると、その変数に対応する値が格納される。  
  値の変数を省略するとキーと同じ名前の変数に値が代入される。  
  キーの順番はマッチの結果に影響しない。  
  値には固定の値や`===`で比較可能な値を指定できる。  
  hashパターンとarrayパターンを混在させることもできる。  
  ハッシュの各要素が`in`節で指定したパターンに部分一致すればマッチしたと判定される。  
  `in`節に`{}`を書いた場合は例外的に空のハッシュに完全一致することがマッチの条件になる。  
  hashパターンの`in`節は`ley: value`形式のパターンしか許容されてないので、`key => value`形式を使おうとすると構文エラーになる。  
  メソッド引数の定義と同様に`**`を使って任意のキーと値を指定できる。  
  `**`が使えるのはパターンの最後だけ。  
  `**nil`を指定したときは他のキーと値がないことを指定する。こうすると完全一致でマッチできる。  
