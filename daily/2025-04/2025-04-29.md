※スクール内timesの移植（2025/09/16）

updateだと問題ないのにsaveだとActiveStorage::FileNotFoundErrorになるなーattachでできるようになったと思ったんじゃが  
updateだと成功するコードがsaveだと失敗するのなんでなんだぜ  
うーんdebug gemでデバッグしてみてるけど、resource.images.attached?はtrueだなー？saveに失敗するのはなんでや。
```bash
eval error: ActiveStorage::FileNotFoundError
  /usr/local/bundle/gems/activestorage-7.2.2.1/lib/active_storage/service/disk_service.rb:152:in `rescue in stream'
  /usr/local/bundle/gems/activestorage-7.2.2.1/lib/active_storage/service/disk_service.rb:145:in `stream'
  /usr/local/bundle/gems/activestorage-7.2.2.1/lib/active_storage/service/disk_service.rb:31:in `block in download'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/notifications.rb:210:in `block in instrument'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/notifications/instrumenter.rb:58:in `instrument'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/notifications.rb:210:in `instrument'
  /usr/local/bundle/gems/activestorage-7.2.2.1/lib/active_storage/service.rb:165:in `instrument'
  /usr/local/bundle/gems/activestorage-7.2.2.1/lib/active_storage/service/disk_service.rb:30:in `download'
  /usr/local/bundle/gems/activestorage-7.2.2.1/app/models/active_storage/blob.rb:284:in `download'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/analyzer.rb:67:in `media_from_tempfile_path'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/analyzer.rb:44:in `media'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/analyzer/content_type_analyzer.rb:33:in `block in read_media'
  /usr/local/lib/ruby/3.3.0/tempfile.rb:447:in `create'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/analyzer/content_type_analyzer.rb:31:in `read_media'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/analyzer/content_type_analyzer.rb:21:in `content_type'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/shared/asv_analyzable.rb:34:in `generate_metadata_for'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/shared/asv_analyzable.rb:22:in `metadata_for'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/content_type_validator.rb:111:in `not_spoofing_content_type?'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/content_type_validator.rb:66:in `is_valid?'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/content_type_validator.rb:40:in `block in validate_each'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/shared/asv_attachable.rb:45:in `block in attachables_and_blobs'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/shared/asv_attachable.rb:44:in `each'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/shared/asv_attachable.rb:44:in `attachables_and_blobs'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/content_type_validator.rb:38:in `each'
  /usr/local/bundle/gems/active_storage_validations-2.0.2/lib/active_storage_validations/content_type_validator.rb:38:in `validate_each'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validator.rb:155:in `block in validate'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validator.rb:151:in `each'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validator.rb:151:in `validate'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:385:in `block in make_lambda'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:179:in `block in call'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:668:in `block (2 levels) in default_terminator'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:667:in `catch'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:667:in `block in default_terminator'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:180:in `call'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:559:in `block in invoke_before'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:559:in `each'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:559:in `invoke_before'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:109:in `run_callbacks'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:913:in `_run_validate_callbacks'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validations.rb:441:in `run_validations!'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validations/callbacks.rb:115:in `block in run_validations!'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:110:in `run_callbacks'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/callbacks.rb:913:in `_run_validation_callbacks'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validations/callbacks.rb:115:in `run_validations!'
  /usr/local/bundle/gems/activemodel-7.2.2.1/lib/active_model/validations.rb:366:in `valid?'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/validations.rb:71:in `valid?'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/validations.rb:91:in `perform_validations'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/validations.rb:48:in `save'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/transactions.rb:362:in `block in save'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/transactions.rb:418:in `block (2 levels) in with_transaction_returning_status'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/connection_adapters/abstract/transaction.rb:616:in `block in within_new_transaction'
  /usr/local/bundle/gems/activesupport-7.2.2.1/lib/active_support/concurrency/null_lock.rb:9:in `synchronize'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/connection_adapters/abstract/transaction.rb:613:in `within_new_transaction'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/connection_adapters/abstract/database_statements.rb:361:in `transaction'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/transactions.rb:414:in `block in with_transaction_returning_status'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/connection_adapters/abstract/connection_pool.rb:421:in `with_connection'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/connection_handling.rb:296:in `with_connection'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/transactions.rb:410:in `with_transaction_returning_status'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/transactions.rb:362:in `save'
  /usr/local/bundle/gems/activerecord-7.2.2.1/lib/active_record/suppressor.rb:52:in `save'
  (rdbg)//myapp/app/controllers/admin/reviews_controller.rb:1:in `create'
nil
```
updateの時にはエラーなく画像を新しくできるからバリデーションとかではない…。  
saveの後だと一応うまくいく :thinking_face:  
ただこの場合は加工前の画像と加工後の画像両方が添付される…上書きにならないんだ。  
んーわからん！結局ReviewsControllerと同じ実装にした

has_manyだとsave前にattachできないみたいなissueはあったけどRails5時代のやつだし結局解決してなかったな。  
→saveの後にReview呼び出してattachも一瞬考えたけど加工前画像をストレージに保存→削除して加工後画像を保存の流れになるからやめとこ
> The :dependent option defaults to :purge_later. This means the attachments will be purged (i.e. destroyed) in the background whenever the record is destroyed. If an ActiveJob::Backend queue adapter is not set in the application set it to purge instead.
dependentオプションのデフォルトは:purge_laterです。これは、レコードが破棄されるたびに添付ファイルがバックグラウンドでパージされる（つまり破棄される）ことを意味します。ActiveJob::Backendキューアダプタがアプリケーションに設定されていない場合は、代わりにpurgeに設定します。
https://api.rubyonrails.org/v7.2/classes/ActiveStorage/Attached/Model.html#method-i-has_many_attached

もしかして：　destroyアクションにpurgeはわざわざ設定しなくてもいい？  
えっまじか…画像だけ消したりするときは画像削除用のアクション作ってpurgeつかう必要あるけど、画像が添付されてる親モデル（postとか）を消すときはdestroyでpurgeしなくていいってことだよねこれ…？  
まじか…まじか…まじか…（でもなんかあって親モデルの削除失敗したら画像だけ消えちゃうから明示的にpurgeしていい気がする）  
`include_hidden: false`も`dependent`のデフォルト設定もガイドとかに書いてないもんわかんないよお～～～

処理を`画像が添付されてるときに加工後の画像を変数に代入→params[:review][:images]自体はnilに変更→save後に加工後の画像をattach`に変更したらcontenttypeのバリデーションエラーでる～～～これもupdateだと問題ないです（どうして）  
モデルファイルのバリデーションでwebp形式は許可出してるよ  
…あ、params[:review][:images]をnilにしたからか？  
だめかー  
送られてきたパラメータを直接いじるのがぶっちゃけ一番楽だよねと思いつつ、画像を添付するときにはattachを使うのが正常っぽいからこれにしたい気持ちもあり…（というかupdateをオーバーライドするときにsuperで省略できるからこっちにしたい）  
元にもどそ…  

- 学習時間：4h/10h/864h
- 学習内容：卒制

天気がめちゃくちゃ悪くてしんどかったので午後から動き始めました。  
最近ちょっと暖かくなってきていたのに、ここにきて急に寒くなったのでやめてほしいなって思います。

画像加工の処理をなんとか`attach`でできんか…と思って格闘してました。  
`update`の時は、userにやったのと似た処理で加工した画像を`attach`したら画像加工して画像アップロードができたので、同じ処理で`create`の時もできるかと思って実装したのですが、`ActiveStorage::FileNotFoundError`が出ました。  
色々と調べていましたが、どうも`has_many_attached`の時は未保存の親モデルに画像を`attach`して保存できないっぽい？です。  
`has_one_attached`の時は問題なく`attach`できるので、たぶん挙動としておかしいのでは…と思います。  
[RAils API](https://api.rubyonrails.org/v8.0/classes/ActiveStorage/Attached/Many.html#method-i-attach)にも、
> If the record is persisted and unchanged, the attachments are saved to the database immediately. Otherwise, they’ll be saved to the DB when the record is next saved.
レコードが永続化され、変更されていない場合、添付ファイルは即座にデータベースに保存されます。そうでなければ、次にレコードが保存されるときにDBに保存されます。

と記載があるので、おかしいのでは…。  
この問題はRails5時代からあるようで、[このissue](https://github.com/rails/rails/issues/31164)では、`after_save`コールバックを使用してこの問題を回避してるみたいです。  
この問題はその後も何度か類似のissueが上がっていますが、解決しないまま時間経過でissueがcloseされる…のを繰り返しているみたいです。  
自分でもいろいろ試してみましたが、結局もともとやってた`build`に渡してるparamsを直接いじるやり方以外は成功しなかったです。  
あんまりここに時間かけてもいられないので、やっぱりparamsを直接いじるやり方で実装しておこうと思います。  

Reviewの管理画面であと実装しておくものあるかなとみていた時に、ちょっと調べ物をしていたら`親モデルを消すときに、destroyにpurgeの記述をしなくても添付されてる画像も一緒に消えてくれる（purgeされる）`というのが発覚しました。  
というのも、何気なく管理画面で投稿を消してみて成功～～～とやった後に、画像消す記述追加してないじゃん！！！と思い出してログを見てみたら画像のDELETE処理が走ってて、アレ！？って思って調べていました。  
どうも
> The :dependent option defaults to :purge\_later. This means the attachments will be purged (i.e. destroyed) in the background whenever the record is destroyed. If an ActiveJob::Backend queue adapter is not set in the application set it to purge instead. dependentオプションのデフォルトは:purge\_laterです。これは、レコードが破棄されるたびに添付ファイルがバックグラウンドでパージされる（つまり破棄される）ことを意味します。ActiveJob::Backendキューアダプタがアプリケーションに設定されていない場合は、代わりにpurgeに設定します。 [https://api.rubyonrails.org/v7.2/classes/ActiveStorage/Attached/Model.html#method-i-has\_many\_attached](https://api.rubyonrails.org/v7.2/classes/ActiveStorage/Attached/Model.html#method-i-has_many_attached)

と、デフォルトで`dependent: purge_later`が設定されているようで、親モデルを削除したら一緒に画像も`purge`されてくれるみたいです。  
こういうガイドにも書いてなかったことは疑問に思うきっかけがないとなかなか調べられないので、まだ知らないことたくさんあるんだろうなって思います。奥が深いぜ。

