
📖[プロを目指す人のためのRuby入門［改訂2版］ 言語仕様からテスト駆動開発・デバッグ技法まで](https://gihyo.jp/book/2021/978-4-297-12437-3)

#### selfキーワード

`self`キーワードはインスタンス自信を表す。  
メソッド内部で他のメソッドを呼び出すときは暗黙的に`self`に対してメソッドを呼び出している。  
`self`は省略可能だが、明示的に`self`をつけてもいい。  

- `self`のつけ忘れで不具合が発生するケース  
  セッターメソッドを呼び出したいときは`self`をつけなければ不具合が出る。  
  セッターメソッドに`self`をつけずに値を代入しようとすると、ローカル変数に文字列を代入したときと同じ構文の形になってしまうので、ローカル変数に代入しようとしたと誤解釈されてしまう。  
  `self.メソッド名 = 値`と書けば、ローカル変数の代入とは構文が異なるので、確実にセッターメソッドを呼び出せる。  

- クラスメソッド内部やクラス構文直下の`self`  
  クラス定義内に登場する`self`は場所によってそのクラスのインスタンス自身を表したり、クラス自身を表す。  
  クラス構文の直下とクラスメソッド内での`self`は「そのクラス自身」を表す。  
  インスタンスメソッド内での`self`は「そのクラスのインスタンス」を表す。  
  `self`が異なるので、クラスメソッドからインスタンスメソッドを呼び出したり、インスタンスメソッドからクラスメソッドを呼び出したりはできない。  
  `self`がクラス自身になるので、クラス構文の直下ではクラスメソッドを呼び出すことができる。  

- クラスメソッドをインスタンスメソッドで呼び出す  
  `クラス名.メソッド名`でクラスメソッドをインスタンスメソッドの内部から呼び出せる。  
  `self.class.メソッド名`と書いても同じことになる。

#### クラスの継承

クラスの継承において、何らかのクラスを継承したクラスをサブクラス（子クラス）、継承元のクラスをスーパークラス（親クラス）と呼ぶ。  
クラスの継承は機能ではなく、性質や概念の共通点に着目して適切かどうかを考える。  
「サブクラスはスーパークラスの一種である（サブクラス is a スーパークラス）」と読んだときに違和感がないかを確かめる。  
違和感がなければ、適切な継承関係である可能性が高い。  
また、サブクラスはスーパークラスの性質を特化したもので、スーパークラスはサブクラスの性質を汎化したものである、という関係も成り立つ。  

- 標準ライブラリの継承関係  
  Rubyの継承は単一継承（継承できるスーパークラスは一つだけ）。  
  Rubyでは、継承関係の頂点にいるのはBasicObjectクラスで、このクラスをObjectクラスが継承している。  
  StringやArrayなどのクラスはObjectクラスを継承している。  

- デフォルトで継承されるObjectクラス  
  継承元を指定せずに作成したクラスは、デフォルトでObjectクラスを継承する。  
  なので、クラス内にメソッドを何一つ定義しなくても、`to_s`等のメソッドを呼び出すことができる。  

- オブジェクトのクラスを確認する  
  `class`メソッドを使うとオブジェクトのクラスを確認できる。  
  `instance_of?`メソッドでも調べられる。  
  継承関係を確認したいときは、`is_a?`メソッドを使う。  

- 他のクラスを継承したクラスを作る  
  ```ruby
  class サブクラス < スーパークラス
  end
  ```
  のようにすれば、Object以外の他のクラスを継承したクラスを定義できる。  

- `super`でスーパークラスのメソッドを呼び出す。  
  `super`を使えば、スーパークラスで`sttr_reader`等が設定されているメソッドをサブクラスで呼び出すことができる。  
  メソッドの中に`super(引数)`と書けば、スーパークラス内の同名メソッドを呼び出せる。  
  スーパークラスとサブクラスで引数が同じなら、引数なしの`super`を呼び出すだけで、渡された引数をすべてスーパークラスに渡せる。  
  `super()`とかいてしまったら、引数0個でスーパークラスの同名メソッドを呼び出す、という意味になってしまうので気を付ける。  
  そもそもスーパークラスとサブクラスで実行する処理が変わらないのなら、サブクラスで同名メソッドを定義したり`super`を呼ぶ必要はない。  
  例えば`initialize`メソッドが同じ処理なら、サブクラスで`new`するだけで自動的にスーパークラスの`initialize`が呼び出される。