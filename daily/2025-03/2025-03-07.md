
📖[プロを目指す人のためのRuby入門［改訂2版］ 言語仕様からテスト駆動開発・デバッグ技法まで](https://gihyo.jp/book/2021/978-4-297-12437-3)

#### モジュールを利用したメソッド定義についてもっと詳しく（つづき）

- モジュールとインスタンス変数  
  モジュール内で定義したメソッドの中でインスタンス変数を読み書きすると、include先のクラスのインスタンス変数を読み書きしたことと同じになる。  
  らだ、モジュールがミックスイン先のクラスでインスタンス変数を直接参照するのは良い設計ではない（インスタンス変数は任意のタイミングで新しく定義されたり、未定義のインスタンス変数を参照できたりするので）。  
  メソッドであれば未定義のメソッドを呼び出したときにエラーが発生するので、特定のメソッドの存在を前提とする方が安全。  

- クラス以外のオブジェクトにextendする  
  モジュールは個々のオブジェクトにもextendすることができる。  
  個々のオブジェクトにextendすると、モジュールはそのオブジェクトの特異メソッドになる。  

#### モジュールを利用した名前空間の作成

- 名前空間を分けて名前の衝突を防ぐ  
  大規模なプログラムや外部に公開するライブラリを作ったりするときは、クラス名の重複が問題になることがある。  
  何らかの理由で、同じ名前のクラスを同時に使う必要が出てきたときに、「名前空間」としてのモジュールを使って区別する。  
  モジュール構文の中にクラス定義を書くと、そのモジュールに属するクラスという意味になるので、同名のクラスがあっても外側のモジュール名さえ異なっていれば名前の衝突は発生しなくなる。  
  モジュールに属するクラスを参照するときは、`モジュール名::クラス名`のようにする。

- 名前空間でグループやカテゴリを分ける  
  名前空間は、クラスのグループ分け/カテゴリ分けをする目的で使われることもある。  
  クラスがたくさんある大きなプログラムになってくると、カテゴリ別にモジュールを作って整理しないと、どれがなんのクラスなのか把握しづらくなる。  
  クラス定義やモジュール定義を保存するファイルパスは、慣習として名前空間をディレクトリ名に、クラス名やモジュール名をファイル名にそれぞれ対応させる。
  ディレクトリ名やファイル名はスネークケースにする。  

- 入れ子なしで名前空間付きのクラスを定義する  
  名前空間として使うモジュールがすでにどこかで定義されている場合は、モジュール構文やクラス構文を入れ子にしなくても、`モジュール名::クラス名`の形で定義できる。  

- トップレベルの同名クラスを参照する。  
  モジュール内で、明示的にトップレベルのクラスやモジュールを指定するときは、クラス名やモジュール名の前に`::`をつける。  
  `::クラス名`のように書く。
  モジュール内とトップレベルで同じ名前のクラスがあって、トップレベルのクラスを参照したい時など…。

- 入れ木尾の有無によって参照されるクラスが異なるケース  
  Rubyではクラスやモジュールの入れ子関係を順に外側に向かってクラスを探す。  
  ```ruby
  module Sample
    class File
    end
  end
  # 名前空間のどこかにこういうクラスの定義があるとする

  module Sample
    class Nest
      def nesting
        puts File
      end
    end
  end

  class Sample::Not_nest
    def not_nesting
      puts File
    end
  end
  ```
  入れ子になっている方は、`Sample::Nest::File`　→　`Sample::File`と順に探していって、`Sample::File`が見つかった時点で探索が終わる。  
  一方、入れ子になってない方は最初に`Sample::Not_nest::File`を探すが、その名前のクラスはないので、入れ子関係の外側に向かう…が、入れ子になっていないとトップレベルが外側になるので、トップレベルに探しに行ってしまう。トップレベルにFileというクラスがあればそれを返してしまう。  
  入れ子の有無によって参照先が変わるので気を付ける必要がある。  