
📖[プロを目指す人のためのRuby入門［改訂2版］ 言語仕様からテスト駆動開発・デバッグ技法まで](https://gihyo.jp/book/2021/978-4-297-12437-3)

#### 例外の補足（つづき）

- 継承関係と`rescue`節の順番に注意する  
  `rescue`節が複数あるときは、上から順番に発生した例外クラスが`rescue`節のクラスにマッチするかどうかチェックしていく。  
  `rescue`節に例外クラスを指定するとそのクラス自身とサブクラスが補足の対象になるので、例外クラスの継承関係と`rescue`節を各順番に注意しないと永遠に実行されない`rescue`節になってしまう。  
  サブクラスとスーパークラスを分けて処理したいときは、サブクラスの処理を先に持ってくる。  
  スーパークラスの処理を先に持ってきてしまうと、サブクラスも補足の対象になってしまうので、サブクラス用の処理に到達しない。  
  サブクラスのエラーを個別で補足して処理をしたときは、最後にStandardErrorクラスを補足するようにすれば、通常のプログラミングで発生するその他のエラーをまとめて補足できる。  

- 例外発生時にもう一度処理をやり直す`retry`  
  一時的に発生している問題が例外の原因なら、何度かやり直すことで正常に実行できる可能性がある。  
  `rescue`節で`retry`文を実行すると、`begin`節の最初からやり直せる。  
  ```ruby
  begin
    # 例外が発生しうる処理
  rescue
    retry # 処理をやり直す
  end
  ```
  無条件に`retry`し続けると、例外が発生しない場合に無限ループを作ってしまう恐れがあるので、カウンタ変数を用意して`retry`の回数を制限するといい。  

#### 意図的に例外を発生させる

`raise`メソッドで意図的に例外を発生させることができる。  
`raise`に文字列を渡すと、その文字列がエラーメッセージになる。  
省略もできるが、例外の原因がわかりにくくなるので、原因を特定しやすいメッセージをつけておく方がいい。  
`raise`に文字列だけ渡すと、RuntimeErrorになる。  
`raise`の第一引数に例外クラス、第二引数にエラーメッセージを渡すと、RuntimeErrorクラス以外の例外クラスで例外を発生させることができる。  
あるいは、`raise`に例外クラスのインスタンスを渡す方法もある。  

#### 例外処理のペストプラクティス

- 安易に`rescue`を使わない。  
  安易に`rescue`をつかってプログラムを続行してしまうと、処理中のデータの構造が崩れたり、別の問題を引き起こす恐れがあるので、異常事態が発生したときはプログラムの実行を即座に中止して例外の原因を調査し、適切な対応を行ってからプログラムを再度実行する。  
  Railsとかだと例外発生時の共通処理が最初から組み込まれているので、自分で`rescue`しなくてもフレームワークに例外処理を委ねることができる。  
  初心者のうちは、「例外が発生したら即座にプログラムを異常終了させる」、もしくは「フレームワークの共通処理に全部丸投げする」、と考えた方が安全。

- `rescue`したら情報を残す  
  例外が発生しても`rescue`しないのが例外処理の原則だが、状況によっては`rescue`すべきケースもある。  
  `rescue`すべきケースのときでも、後で原因調査ができるように、例外次の状況を確実に記録に残す必要がある。  
  `full_message`メソッドを使うと、例外クラス名、エラーメッセージ、バックトレースの3つをログやターミナルに出力できる。  
  例外を`rescue`したらその場で情報を残さないと詳細な情報が失われてしまうので、詳細な情報を確実に残す。  