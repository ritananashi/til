
📖[プロを目指す人のためのRuby入門［改訂2版］ 言語仕様からテスト駆動開発・デバッグ技法まで](https://gihyo.jp/book/2021/978-4-297-12437-3)

#### 例外処理についてもっと詳しく

- ensure  
  例外が発生してもしなくても必ず実行したい処理が出てきたときは、例外処理に`ensure`節を加えると必ず実行され鵜処理を書ける。  
  ```ruby
  begin
    # 例外が発生するかもしれない処理
  rescue
    # 例外発生時の処理
  ensure
    # 例外の有無にかかわらずに実行する処理
  end
  ```
  `rescue`節は必須ではないので、異常終了してもいいが、終了する前に必ず実行したい処理があるときは`ensure`節だけ書くこともできる。  

- ensureの代わりにブロックを使う。  
  例えばファイル処理の`open`メソッドは、ブロックを渡すことでensure節やクローズ処理を書かなくてもブロックの実行中に例外が発生したら、必ずクローズ処理を実行してくれる。  
  使用したら必ずリソースを開放するというような処理は、rubyではブロック付きのメソッドを使うことで自動的に処理できるケースが多い。  
  `ensure`節を自分で書く前に、こうした便利なメソッドが用意されていないか、公式リファレンスを確認する癖をつける。  

- 例外処理のelse  
  例外処理では、例外が発生しなかった場合に実行される`else`節を書くこともできる。  
  ```ruby
  begin
    # 処理
  rescue
    # 処理
  else
    # 例外が発生しなかった場合の処理
  ensure
    # 処理
  end
  ```
  `begin`節に例外が発生しなかった場合の処理を書いてしまえばいいので、`else`節を書くことはあんまりない。  
  `else`節で実行されたコードは、エラーが起きても、その手前に書かれた`rescue`節で補足されない。  

- 例外処理と戻り値  
  例外処理にも戻り値がある。  
  例外が発生せずに最後まで処理が進んだ場合は、`begin`節の最後の式が戻り値になる。  
  例外が発生してその例外が補足されたときは`rescue`節の最後の式が戻り値になる。  
  メソッドの戻り値として使うこともできる。  

- $!と$@に格納される例外情報  
  最後に発生した例外は組込み変数の`$!`に格納されて、バックトレース情報は`$@`に格納される。  
  可読性を考えると使わない方がいい。  

- 例外処理のbegin/endを省略できるケース  
  メソッドの中身全体が例外処理で囲まれている時は`begin`キーワードと`end`キーワードを省略できる。  
  `do/end`ブロック内部でも`begin`と`end`を省略できる。  
  ただ、ブロックでも`do/end`ではなく`{}`を使ったときは省略できない。

- rescueした例外を再度発生させる  
  `rescue`節の中で`raise`メソッドを使うこともできる。  
  この時`raise`メソッドの引数を省略すると、`rescue`節で発生した例外をもう一度発生させることができる。  
  例外が発生したときにプログラム自体は異常終了させたいが、情報はログに残したりメールで送信したりしたいときにこのテクニックが使える。  