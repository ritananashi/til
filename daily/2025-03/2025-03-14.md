
📖[プロを目指す人のためのRuby入門［改訂2版］ 言語仕様からテスト駆動開発・デバッグ技法まで](https://gihyo.jp/book/2021/978-4-297-12437-3)

#### 例外処理についてもっと詳しく（つづき）

- 独自の例外クラスを定義する  
  例外クラスは独自に定義することもできる。  
  例外クラスを定義するときは、特別な理由がない限りはStandardErrorクラスか、そのサブクラスを継承する。  
  必要であれば独自のメソッドや独自の属性を追加することもできる。  

10章。`yield`と`Proc`の章。ハンズオンはワードシンセサイザー（？）与えられた単語を逆順にしたり、指定された回数だけ各文字を連続させたり大文字にしたりするプログラムを作成する。

#### ブロックを利用するメソッドの定義と`yield`

- `yield`を使ってブロックの処理を呼び出す  
  ```ruby
  def greet
    puts 'おはよう'
    puts 'こんばんは'
  end
  #=> おはよう
  #   こんばんは

  greet do
    puts 'こんにちは'
  end
  #=> おはよう
  #   こんばんは
  # エラーは起きないが出力結果も変わらない。

  def greet
    puts 'おはよう'
    yield # ここでブロックの処理を呼び出す
    puts 'こんばんは'
  end

  greet do
    puts 'こんにちは' # greetメソッドのyieldに挿入される。
  end
  #=> おはよう
  #   こんにちは
  #   こんばんは
  ```
  `yield`を使うと、メソッドの実行時にブロック内の処理を実行できる。  
  メソッドを実行したときに、メソッド内の処理を上から実行していって、yieldのところでブロック内の処理を実行する。  
  `yield`を複数回書いたらその都度ブロック内の処理が呼ばれる。  
  メソッド内に`yield`が書かれてるけどメソッド呼び出し時にブロックがなかったらエラーになる。  
  `block_given?`メソッドでブロックが渡されているかを判定できる。  
  `yield`はブロックに引数を渡したり、ブロックの戻り値を受け取ったりできる。  
  `yield`とブロックでやり取りする引数は個数の過不足に肝要なので、`yield`で渡した引数がブロックパラメータよりも多かったり、ブロックパラメータが`yield`で渡した引数より多かったりしてもエラーにはならない。  

- ブロックを引数として明示的に受け取る。  
  ブロックをメソッドの引数として明示的に受け取ることもできる。  
  ブロックを引数として受け取るときは、引数の前に`&`をつける。ブロックを実行するときは`call`メソッドを使う。  
  ```ruby
  def メソッド(&引数)
    # ブロックを実行する
    引数.call
  end
  ```
  引数の名前は自由につけられる。  
  ブロックの引数はメソッド定義につき1つしか指定できない。  
  他の引数があるときはブロックの引数を必ず最後に指定する。  
  ブロックを引数として受け取るときでも`yield`や`block_given?`メソッドを使うことができる。  
  ブロックを引数にすると、ブロックを他のメソッドに引き渡せるようになる。  
  ```ruby
  def メソッド(&引数)
    # ブロックを別のメソッドに引き渡す
    別のメソッド(&引数)
  end

  def 別のメソッド(&引数)
    # ブロックを実行する
    引数.call
  end
  ```
  他のメソッドにブロックを引き渡すときは、引数の手前にも`&`をつける。  
  `&`をつけないと普通の引数と見なされる。  
  他にも、渡されたブロックに対してメソッドを呼び出し、必要な情報を取得したり、ブロックに対する何かしらの操作を実行したりできるようになる。  
  `arity`メソッドでブロックパラメータの関数を確認できる。  

#### `Proc`オブジェクト

- `Proc`オブジェクトの基礎  
  `Proc`くらすはブロックをオブジェクト化するためのクラス。  
  `Proc`は何かしらの処理を表す。  
  `Proc`クラスのinスタンを作るときは、`Proc.new`にブロックを渡す。  
  ```ruby
  hello_proc = Proc.new do
  'Hello!'
  end

  hello_proc = Proc.new{ 'Hello!' }
  ```
  `Proc`オブジェクトはオブジェクトとして存在しているだけではまったく実行されないので、実行したいときは`call`メソッドを使う。  
  実行時に引数を利用する`Proc`オブジェクトも定義できる。  
  ```ruby
  add_proc = Proc.new{ |a, b| a + b }
  add_proc.call(10, 20) #=> 30
  ```
  引数にデフォルト値をつけることもできる。  
  可変長引数やキーワード引数など、普通のメソッドと同じように引数を受け取ることもできる。  
  `proc`メソッドを使うことでも`Proc`オブジェクトを作成できる。  
  `add_proc = proc { |a, b| a + b }`  
  Javascriptの関数オブジェクトみたいなもの。  
