
:open_book:教材：[パーフェクトRuby on Rails【増補改訂版】](https://gihyo.jp/book/2020/978-4-297-11462-6)

### Railsアプリケーションのインフラ概要

Railsを単体で稼働させるだけなら、それほどインストールしなければならないものは多くないが、本番環境で操作させるには様々なコンポーネントが必要になる。  
かつては各環境ごとに設定手順書やスクリプトを手書きして、サーバーを構成することが主流だったが、設定手順書やスクリプトを実際の環境に合わせて適切に更新し、運用し続けるのはかなりの負荷を伴うため、運用不可の問題を改善するためにサーバーを自動構成するためのDSLを提供するツールを利用するようになった。  
ツールを使って設定を更新することで、設定変更が常にリポジトリにあるコードベースと一致することになり、コードを用いて実際の環境との不一致を解消し、差分管理のしやすいインフラ構成を実現しようという流れ（Infrastracture as Code）があった。  
だが、自動構成するためのDSLは基本的にべき等になるように記述しなければならないといった制約があったことから、柔軟な攻勢を実現するためにはある程度の工夫が必要だった。  
コンテナ技術をつかっても、インフラ構成にそのまま利用するにはかなり工夫が必要だったが、Dockerの登場で状況が大きく変わった。  
アプリケーションやミドルウェアの動作環境を丸ごとパッケージして提供したり、1つのOSに中で複数のコンポーネントを動作させることがとても簡単になった。  
また、コンテナは再構成とパッケージングが容易なため、設定を変更する場合は元のコンテナを捨てて新しく作り直せば良いことから、べき等性を意識して新しいDSLを作りこまなくても柔軟アン設定変更が可能になった。  
こういったインフラをDisposable（破棄可能）であると表現することもある。
Docker登場以後はWebアプリケーションを動作させる基盤としてコンテナを利用することは一般的となった。

### 基本的なDockerイメージの構築

Dockerイメージを作成するにはDockerfileというファイルにDSLを記述する。  
ビルドステップごとにファイルシステムの変更差分を積み重ねることでイメージを作成していく。  
先にGemfileをイメージに組み込んでbundle installを実行しておかなければ、ソースコードを変更するごとに毎回bundle installする必要が出てくるため、ビルド時間が延びる。  
カリキュラムで提供されていた見本のDockefileではdocker-composeのほうにbundle installが記述されていた。どちらでもいいのか？
Dockerイメージのビルドは、アプリケーションに何らかの更新を加えて新しくデプロイするときには必ず実行することになるので、ビルド時間が長くなると開発サイクルの中で失われる時間が馬鹿にならなくなる。  
そのため、ビルド時間を短く保つことは開発環境の快適さに大きく影響する。  
先にGemfileをイメージに組み込んでbundle installを実行しておけば、Gemfileの内容に変化がなかった場合はbundle installのこうていまでキャッシュを使用することが可能になるので、2回目以降のビルドが大きく高速化される。
Gemfileの中身を更新したり、bundle updateの結果Gemfile.lockが更新されたら、またGemfileのコピーから実行される。  
assets:precompileはステップキャッシュを利用して高速化することが難しいので、buildkitを使用して解決する。  
.dockerignoreファイルでホストには存在しているけれどDockerイメージには組み込みたくないファイル群設定する。  
.gitやvendor/bundle、log、tmp等、プロジェクトに合わせて適宜追記する。  

Dockerfileを記述した後に、Railsプロジェクトのルートで`docker build -t 任意の名前`を実行するとイメージが作成される。  
この状態でdocker runをしてDockerを起動し、localhpst:3000にアクセスすると、Docker上のアプリケーションにアクセスできる。  

Dockerのレイヤーキャッシュのほかに、ビルドを高速化させる仕組みとしてbuildkitのマウントキャッシュがある。  
buildkitはDockerのv18.09から採用された新しいコンテナビルド方式で、マウントキャッシュを使うとイメージビルド内に書き込んだファイルをホストマシン上にキャッシュして保存しておくことができる。  
buidle installを行った後の状態を保持できるので、ホストマシン上でbundle installを行った後の状態を保持できるようになる。  
また、cacheを利用することで、assets:precompileの実行時間も大幅に削減できるようになる。  
assets:precompileはもともtmp/cacheにビルド結果をcacheしておいて、2回目以降はそのcacheを利用する仕組みだったが、今までのdocker buildだとcacheを活用することが難しかったが、マウントキャッシュが使えれば、個別のイメージビルドでassets:precompileを簡単に使いまわせるようになる。  
マウントキャッシュを使うには、1行目に`# syntax = docker/dockerfile:experimental`と記述する。  
キャッシュ用のディレクトリを指定すると、そのステップではキャッシュ用のディレクトリが作成されて、書き込みできるようになる。  
マウントキャッシュはビルドステップが変わるとアクセスできなくなるし、イメージファイルの中にも残らない。  
なので、RubyやNodeのパッケージをイメージに取り込むために、一時的にキャッシュディレクトリをインストール先に指定して、通常のインストール先にコピーして設定を戻すというステップが必要になる。  
また、buildコマンドを実行する際にDOCKER＿BUILDKITという環境変数に何らかの値を代入しておく必要がある。  

Dockerを利用すると、ChefのDSLを覚えたり、べき等性を意識したりする必要がないため、非常に簡単に実行環境をパッケージングできる。  
また、Rubyの実行環境自体も一緒にパッケージングできるので、Rubyのバージョンアップを検証することが非常に容易になる。  

### 開発環境におけるDockerの活用

Dockerコンテナは環境の再現性が高く、一度イメージを作ってしまえば様々なシステム下でほぼ同じ環境を維持したまま動作できる。  
Rubyの実行環境やネイティブライブラリは、イメージを作成した状況と同一のものが本番環境で動作するので、開発環境と本番環境の双方でDockerを利用すると、本番環境に非常に近い環境を維持して開発できる。  
しかし、本番環境と非常に近い開発環境を構築したいといっても、ソースコードの反映方法は開発環境と本番環境で異なってしまう。  
開発中にソースコードを編集した場合、結果は即座に稼働中のサーバーに反映されてほしいが、そのたびにDockerイメージを構築しなおしてコンテナを再起動するのは手間が大きい。  
なので、一般的には開発環境でDockerを使うときは、ホストマシン上のディレクトリをコンテナ上にマウントさせる。  
macOSを使っている場合はのDockerはLinuxのVMを経由して動作させる必要があるので、ファイルアクセスのパフォーマンスが低下することがあるが、ディレクトリをマウントするときのコマンドを`-v $(pwd):/app:cached`にするとある程度パフォーマンスの低下を緩和できる。  
マウントキャッシュを利用してホストマシン上のディレクトリをビルド中のコンテナ内にマウントすると、ファイルのuid、gid、modeはホストマシン上の値と同じになる。  
一方で、コンテナ内でファイルを作成するとrootとして捜査したことになり、ファイルはuid=0で作成されるが、ホストマシン上のディレクトリをマウントした場所だった場合、ホストマシン上にuid=0のディレクトリが作成されることになるので、ファイルのownerやパーミッションの値に注意する必要がある。  

開発環境においてRails単体以外に多くのコンポーネントが必要になるときに、Dockerは本領発揮する。  
Dockerを活用することでミドルウェアのインストールや観光構築手順を大きく簡易化できる。  
docker-composeを利用することで、複数のコンテナイメージを組み合わせて一度に起動してくれる。  
`docker-compose run --service-port`のように、run時には`--service-port`を指定しないとポートマッピングが無効になるため、ホストマシン側から接続できなくなる。  
コンテナを停止させたいときは`docker-compose down`を実行するとdocker-composeで起動していたすべてのこんてなを終了してくれる。  
docker-composeには、コンテナの独立性を維持しつつ、各コンテナ相互の接続を可能にする設定を簡単に記述できるようになるという大きなメリットがある。  
