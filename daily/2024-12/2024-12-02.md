
:open_book:教材：[パーフェクトRuby on Rails【増補改訂版】](https://gihyo.jp/book/2020/978-4-297-11462-6)

#### 8-2 gemで機能拡張する

Kaminariでページネーション機能を作る  
gem Kaminariを導入してページネーション機能を追加。  
ページネーションがないと、登録された未開催のイベント情報をすべて表示してしまい、サーバーに必要以上の負荷をかけてしまう上にユーザーにとっても見にくいページになる。  
KaminariはBootstrapやfoundationなどで使えるテーマが用意されており、`rails g kaminari:views bootstrap4`を実行するとapp/views/kaminari/配下にBootstrap4用のビューテンプレートを生成する。  
i18n用の設定を追加して完了。

Searchkickでイベント検索機能を作る。  
検索の仕様がシンプルだったり、検索対象のレコード数が少ないときはActiveRecordのクエリメソッドを使用して検索機能を実現することができるが、使用が複雑だったり、検索対象のレコードが多い場合はActiveRecord単体での検索機能を実現するのが難しく、特に文章を検索するときにインデックスを利用できないなどの問題がある。  
こうした場合に、Elasticsearchなどの全文検索エンジンを利用するケースが多い。  
ElasticsearchはRailsやDBとは別のプロセスで動き、インデックスやドキュメントといったデータをElasticsearch内部で保持するので、RailsでElasticsearchを扱うにはDBとElasticsearchを連携させるような処理が必要になる。  
今回はこうした処理を自動でやってくれるgemとしてSearchkickを使用する。  
まずはElasticsearch用のDockerfileを別で作成し、compose.ymlを編集してElasticsearchのコンテナを作成する。  
一緒に日本語の形態要素解析エンジンであるKuromojiもインストールする設定にする。  
Kuromojiを使うと、日本語を形態素と呼ばれる単位に分割して、自然な日本語で検索できるようになる。  
ビルドしなおして、KuromojiとElasticsearchが起動しているのを確認する。  
GemfileにSearchkickを追加。  
EventモデルにSearchkick用の設定を追加。モデル中でsearchkickメソッドを実行することで、Searchkick用のメソッドをモデルに追加できる。  
さらに、language: "japanese"オプションを追加することで、検索にKuromojiを使える。  
search_dataメソッドを定義して、検索フォームで入力するキーワードにマッチさせる情報と、イベント開始時間をドキュメントとして登録する。  
search_dataメソッドの戻り値が実際にElasticsearchのインデックスに追加される情報になる。  
`rails r Event.reindex`を実行したところで、`uninitialized constant Elasticsearch::Transport (NameError)`エラーが発生。  
Elasticsearchで使う定数が未定義？というエラーのようだけど、Gemfile.lockにはElasticsearchはインストールされていることになっている…。  
サンプルリポジトリとverが違ったのと、Elasticsearch導入記事を色々見てみたらgemでElasticsearchを追加している記事も多かったので、Gemfileに`gem 'elasticsearch', '7.6.0'`を追加してみたらエラーが消えた。  
verが変わって定数が変わったとかなのだろうか？  
続けてキーワードと開催日時を指定して検索できる検索フォームをイベント一覧に追加。  
条件が簡単なのでGETでリクエストを投げるようにするが、複雑な検索フォームに多くの検索条件を入れると検索クエリが長くなり、ブラウザの規定するURLの長さの上限を超えることがあるので、複雑な検索フォームを作るときはPOSTを利用する。  
form_withにはフォーム用のモデルオブジェクトを渡す。  
モデルを渡さなくてもフォームを作ることはできるが、コントローラーの設計が独自石器になりやすくなってしまう。  
form_withにモデルを渡すと、AcctiveRecordのオブジェクトをフォームに渡したときと同じように設計できるため、読みやすいコードになる。  
form_withはデフォルトでajaxリクエストを送るが、TurbolinksはformによるajaxでのGETリクエストに対応していないので、app/javascript/get_form_turbolinks.jsファイルを追加しformによるGETリクエストをTurbolinks環境でリンクをクリックしたのと同じ挙動に変換する。  
form用のモデルオブジェクトを作るときは、最初にActiveModel::Modelをインクルードするとモデルとして必要なふるまいを追加できる。  
ActiveModel::Attributesモジュールのattributeメソッドを使うので、ActiveModel::Attributesもインクルードする。  
start_atに関しては、フォームからの入力がないときに現在時刻をデフォルト値にしたり、ドームから文字列で入力された日時をActiveSupport::TimeWithZoneオブジェクトに変換するなど独自の処理が必要なので、セッターとゲッターを独自に定義する。  
Event.searchがsearchkickで検索するときのメソッド。”*”で検索するとすべての検索結果が表示されるので、なにも入力がないときは"*"で検索するようにする。  
searchkickはデフォルトでページネーションに対応しているので、ページングはpageとper_pageオプションをsearchメソッドに渡すだけで使える。  
最後にコントローラーを修正して検索機能の実装完了。

#### 8-3 落穂ひろい

エラーハンドリング  
アプリケーション中に例外が発生した場合に備えて、適切なハンドリングを用意する必要がある。  
Railsにはコントローラーでrescue_fromメソッドを使う方法と、エラーハンドリング用のRack Middlewareを利用する方法の2種類のエラーハンドリング方法が存在する。  

rescue_fromを利用したエラーハンドリング  
アプリケーション全体の振る舞いとして特定の例外に対する挙動を指定したいときはrescue_fromメソッドを使う。  
rescue_fromメソッドをによる例外クラスの取り扱いは、ApplicationControllerで定義する。  
rescue_fromで例外クラスを指定して、withオプションで例外発生時に呼ばれるアクションを指定できる。  
エラーが発生したときのリクエストがHTML以外のフォーマットを要求していた場合、何もしないと対応するテンプレートがないのでActionView::MissingTemplateエラーになってしまってエラー画面が正しく出力できないが、renderメソッドにformats: [:html]オプションを渡すと、リクエストがどんなフォーマットを要求していてもHTMLのみを返すようになる。  
アクションに対するビュー（404.html.haml、500.html.haml）を用意。  
routes.rbに定義されていないURLがリクエストされた場合、エラーはRack Middlewareで発生するので、コントローラーで定義しているrescue_fromではキャッチできないので、ルーティング設定の最後にすべてのURLをキャッチする設定を追加して対応する。  

Rack Middlewareを利用したエラーハンドリング  
rescue_fromを利用したエラーハンドリングではRack Middlewareで発生したエラーを検知することができないため、エラーハンドリングを行うRack Middlewareで、Rack Middlewareで発生したエラーを検知する。  
Railsがデフォルトで提供しているRack MiddlewareにActionDispatch::ShowExceptionsというものがあり、ここでキャッチした例外はRails.application.config.exceptions_appとして設定されたRackアプリケーションで処理されて、デフォルトではActionDispatch::PublicExceptionsのインスタンスが設定される。  
ActionDispatch::PublicExceptionsは例外クラスによって表示するHTMLを切り替えるようになっており、例えばActionController::RoutingErrorであればpublic/404.htmlを表示しようとする。  
該当するhtmlがなければpublic/500.htmlを表示する。  
アプリケーション内で定義した独自の例外が発生したときにpublic/500.html以外を表示したいときはconfig.action_dispatch.rescue_responsesを修正して設定する。  

Rack Middlewareで発生したエラーを、ERBやHamlを利用して動的なHTMLをエラーページとして使いたいときはrambulanceなどのgemを利用するのが一般的だが、エラーページの生成中にエラーが起きて正しくエラーページを表示できないなどのデメリットがある。

エラーの通知方法
想定していないエラーである500エラーが発生したとき、exception_notificationなどのgemを使用すると開発者に通知を送ってくれるが、エラーが大量に発生した際に通知が大量に送信されてしまったり、エラーに誰がどのように対応したかなどを管理したり特定のエラーを無視する、などの細かい調整が難しい。
仕事でRailsアプリケーションを運用するなら、外部のWebサービスを利用してエラー情報を管理するといい。

ルーティングの制限
使わないルーティング設定を残すと、rails routesなどの出力結果にノイズが含まれたり、使わないルーティングにアクセスされた場合にAbstractController::ActionNotFoundエラーが発生する。
onlyオプションで利用するアクションを限定しておくといい。
