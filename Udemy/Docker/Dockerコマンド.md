# Dockerコマンド
- `docker login`  
  Docker Hubにログインできる。  
- `docker run イメージ名`  
  Dockerコンテナをひとつ起動する。  
  パソコンにあるDocker imageからDockerコンテナを起動する。  
  Docker imageがローカルにないときは、Docker Hubから自動的にDLしてくれる（なので`docker login`しとかないとpull制限がかかる）。  
  `--rm`でコンテナが停止した後コンテナを消してくれる。 
  `--name`でコンテナに任意の名前を付けられる。
  - `Docker run -v ホスト側の共有したいディレクトリのパス:コンテナのパス イメージ名`  
  コンテナにボリュームをマウントして共有するコマンド  
  ホスト側のマシンのディスクとコンテナのボリュームを共有することができる。  
  ホスト側のディレクトリとコンテナ側のディレクトリを一致させるので、片方をいじってももう片方に変更が共有される。
- `docker ps`   
  起動中のコンテナを表示する。  
  停止中のコンテナは表示されないので、表示させたいときは`-a`オプションを付ける。  
- `docker start コンテナ指定`
  ※コンテナ指定はコンテナIDかコンテナ名のこと  
  コンテナを起動する。  
- `docker stop コンテナ指定`  
  コンテナを停止する。  
- `docker restert コンテナ指定`  
  コンテナを再起動する。  
- `docker exec コンテナ指定 実行コマンド`  
  起動中のコンテナ内でコマンドを実行する。 
  - 起動中のコンテナに入らずにコマンドを実行する。
  - `-it`オプションを使うとコンテナに入ることができる。  
    この時は`docker exec -it コンテナ指定 /bin/bash`になる？
- `Docker rm コンテナ指定`  
  停止中のコンテナを削除する。  
  `-f`オプションで起動中のコンテナを消すことができるが、コンテナのデータも消えるので注意  

- `Docker images`  
  ローカルにあるimageをすべて表示する。  
  Docker imageは意外と容量が大きいので、たまに確認していらないものは消したほうがいい。  

- `Docker rmi`  
  Docker imageを削除する。  
  起動中のコンテナイメージは削除できない。  
  コンテナがあるのに設計図がない状態になってしまうので、コンテナを削除してからイメージを削除する。  
  また、Docker imageは依存関係があるので、ベースイメージは削除できない。  
  ※例えば、PHPだと、PHPのベースイメージ以外にPHP7.4や8.0といった各バージョンの差分がある場合、DockerイメージはPHP8.0等のデータの差分だけ持っている。ベースイメージをベースにバージョン違いで変わったところだけ持っている。ここは解説が途中で途切れた？ぽいのでよくわからない。PHP8.0等のイメージを先に消さなければならないということか？

- `docker build Dockerfileのパス`  
  Dokerfileからイメージを生成する。

- `docker cp`  
  コンテナとホストマシンでファイルのやりとりを行うコピーコマンド。  
  ログファイルや設定ファイルの取り出し or 入力でつかう。  
  - ホスト→コンテナへコピー  
    `docker cp ホストファイルのパス コンテナ指定:コンテナのパス`
  - コンテナ→ホストへコピー  
    `docker cp コンテナ指定:コンテナファイルのパス ホストのパス`

- `docker logs コンテナ指定`  
  Dockerコンテナのログを出力する。
  `-f`オプションでリアルタイムログが見れる。
  原因不明のコンテナ停止時やアクセスログを確認したいときなどに。

- `docker inspect 指定`  
  Dockerの詳細情報の出力。  
  普段は見ない詳細情報を見ることができる。  
  トラブル時に使用する。  
  MountsやConfigをよく見るらしい。あとは環境変数や実行されているコマンドも見ることができる。  
  ネットワークセッティングのコンテナのIPアドレスが必要になったときに見たりする。  
  IPAddress:内部IPアドレス ← 内部IPアドレスはホストマシンからアクセスるときだけ使える。  

- `docker pull イメージ名:タグ`  
  Dockerイメージをダウンロードできる。  
  pullのうしろにプライベートレジストリを付けると、Docker Hub以外からイメージをダウンロードできる。  
  Docker Hubは開かれた場所で、だれでもDockerイメージを見ることができてしまう。  
  そのため機密情報を含むイメージを扱う場合はDocker Hubではなく、プライベートレジストリを借りたり自分で作ったりして、そこからDockerイメージをダウンロードする必要がある。
- `docker commit コンテナ指定 DockerHubID/イメージ名:タグ`  
  コンテナをイメージ化するコマンド。  
  ふつうはイメージからコンテナ化するが、その逆をやる。  
  Dockerfileを使っているとあまり使うことはないが、コンテナに操作を加えたうえで、コマンドを直接打った後にイメージ化したい場合に使う。  
  コンテナに新しいレイヤーを追加してその状態をイメージ化したいときとか。  
  この後`push`コマンドでDocker Hubにプッシュするので、コマンドを打つときに必ずアカウントIDを入れる。

- `docker push アカウント名/イメージ名`  
  自分のオリジナルイメージを自分のDocker Hubアカウントにアップするコマンド。  
  アップしたらほかの人もDLできる。  
  Dockerイメージを公開しておくとDockerわかってるアピールになる。  
  Dockerイメージ、dockerfile、Docker composerを併せて載せるとインフラスキルのアピールになる。

- `docker history イメージ指定`  
  イメージの履歴の確認ができる。  
  他人が作ったイメージの中身を知りたいときに使う。  
  Dockerfileがあれば履歴もわかるので、Docker Hubから直接DLしてきたイメージ等Dockerfileがないときにつかう。  
  Docker Hubから直接DLしたイメージは中身がどういう履歴で作られているのかわからないのでこのコマンドを使う。

# Dockerfileコマンド
- RUNとCMD  
  どちらもLinuxのコマンドを実行するけど、実行タイミングが異なる。  
  RUNは**Dockerfile　→　イメージ**  
  CMDは**イメージ　→　コンテナ**  

  CMDはexec形式での記述が推奨されている。  
  Jsonの配列形式で記述するので、必ずコマンドを`""（ダブルクオーテーション）`で囲む。`''（シングルクオーテーション）`だとコマンドとして認識されない。  
  参考：[docker-docs-ja - dockerfileリファレンス - CMD](https://docs.docker.jp/engine/reference/builder.html#cmd)

  ```Dockerfile
  FROM ubuntu:20.04
  # ベースイメージ：ubuntuのVer20.04
  RUN apt-get update -y && \
  # パッケージのアップデート。&&はレイヤーをひとつにまとめるコマンド。
    apt-get install -y nginx
  # nginxのインストール。ここまでがdocker build時に実行されてイメージになる。
  CMD["nginx","-g","demon off;"]
  # RUNコマンドで作られたイメージからコンテナを立ち上げる。demon offはnginxをフォアグラウンドで稼働させるコマンド。
  ```
  ```Dockerfile
  ...
  RUN apt-get update -y
  RUN apt-get install -y nginx
  # RUNコマンドはこう書いてもいいが、RUNが2個あるので、レイヤーが2つ作られてしまう。
  # 動画では、updateとinstallは似たコマンドなので&&で一つのレイヤーにまとめて
  # レイヤーイメージの縮小を図るとのこと。
  # \で改行になる。
  ```
  - `decker build -t`でイメージに名前を付けられる。
  - `docker run -d`でバックグラウンド起動。
- COPYとADDコマンド  
  どちらもファイルをイメージに追加する命令。  
  ADDはネット経由からもファイルをダウンロードできたり、tar/zipみたいな圧縮ファイルでも追加できる。  
  Docker公式はCOPYを推奨しているので、ADDよりCOPYを使った方がいい。  
  機能が絞られていた方が間違いがないし、基本的にホストのファイルを追加するだけで十分なことができる。  
  ```Dockerfile
  COPY ホストのファイル コンテナのパス
  # docker buildでホストのファイルが指定したコンテナのパスの中に入る。
  ```
  COPYの使いどころ
  - イメージにプログラムのソースコードを入れたいとき
  - 設定ファイルをあらかじめソフトのほうに入れておいて、設定ファイルが反映された状態でイメージを作りたいとき
- ENV  
  環境変数を設定するコマンド。  
  DockerfileがDockerイメージにbuildされるタイミングで環境変数を決めておける。  
  - DBのユーザー名
  - 動作環境（localとかproductionとか） 
  等によく使う。
  ENVは直接書き込みなので固定値になってしまうから、環境によって環境変数の値を出し分けたいときには使えない。
  ```dockerfile
  ENV TESTENV=testvalue
  # キー＝バリューで書く。なんでもいい。
  ENV APP_ENV="production"
  # アプリの環境についての設定。よく使う？らしい。
  # 複数設定できるので並べて書いていい。
  ENV key value
  # こういう書き方もある。
  ```
# docker-compose  
- imageとbuild  
  ```yml
  version: "3" # 3が最新バージョン
  services: # この中に稼働するコンテナが入る。
    web: # サービス名。なんでもいい。
      build: ./php # web等の中身。
  # buildはDockerfileからビルドするときにつかう。Dockerfileが置いてあるディレクトリへの相対パスを書く
    db:
      image: mariadb: 10.4
  # imageはDockerイメージを指定してビルドする。
  ```
  imageとbuildはコンテナイメージを指定する項目。  
  image → DockerHubから指定。  
  build → Dockerfileのパスを指定。  
  必ず実際に動くDockerイメージを指定する必要があるので、service:の下にはbuildかimageのどちらかを書く。書かないとエラーになる。  
  基本はDockerfileからやった方がいいが、カスタマイズする必要がないならimageで持ってきた方が読むほうもわかりやすい。
- container_name  
  コンテナに任意の名前を付ける。  
  `docker run --name`と同じ。
  自由に名前を付けていいが、名前を付けるときは`" "（ダブルクオーテーション）`で囲む。  
  （ただ、調べたら囲んでないものが結構ヒットしたのでなくてもいいのかも…？）  
  すべてのサービスにつけておくのがおすすめ。
- volume  
  `docker run -v`と同じ。  
  コンテナとホストのディレクトリを共有する命令。  
  ```yml
  ...
    volume:
      ホストのパス:コンテナのパス
  ```
  コードやデータや設定ファイルといった必要なデータをホストとコンテナで共有するためにつかう。  
  ホスト側は相対パスで書く。
- ports
  コンテナのポート開放とポートフォワーディングを行うオプション。  
  [ポート開放（読：ポートカイホウ）とは - 「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word110593.html)  
  [ポートフォワーディング（読：ポートフォワーディング　英：port forwarding）とは - 「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word12663.html)

  ```yml
  version: "3" 
  services:
    web:
      build: ./php
    ports:
      "8080:80" # 改行して" "で囲んで記述する。
  # コンテナのポートを、外には8080番を開放して、開放するところは80番につなぐポートフォワーディングをする。
    db:
      image: mariadb: 10.4
  ```
  `docker run -p`オプションと同じ。  
  webサーバは基本80番ポートで開いているけど、複数のポートがかぶるコンテナは立ち上げられない。  
  なので、ポートフォワーディングで外部公開ポートをずらしてあげることで、一つのPCの中に複数のwebサーバを起動することができる。
  
- `docker compose down`  
  docker-compose.ymlで管理されているコンテナをストップして削除するコマンド  
  今いるディレクトリのdocker-compose.ymlのみ適用。  
  今いる階層にdocker-compose.ymlがなかったら上の階層を探しに行く。  
- `docker compose resert`  
  downやupと似たようなコマンド。  
  docker-compose.ymlで管理されているコンテナをすべて再起動する。
- `docker compose ps`  
  docker-compose.ymlで管理されているコンテナ一覧を表示。
  複数のプロジェクトを立ち上げている時に使うと読みやすい。
- `docker compose run サービス名`  
  docker-compose.ymlで管理されているサービス一つを指定してコマンドを実行する。
  ビルド前でも実行できて、フレームワークのインストールなどで使うと便利
