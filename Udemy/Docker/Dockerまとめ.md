
# なぜDockerが必要か？
- 環境構築時間の削減  
　今までは環境構築するとなると
  - webサーバーをインストール
  - 使用する言語をインストール
  - DBをインストール
  - 初期設定をする
  - ユーザーやネットワークを作る…  
  といった作業が必要だった。  
  Dockerでは
  - 設計図を作る
  - `docker compose build, docker compose up`  
  のみで環境構築が行える。  
  Dockerは設計図通りに環境構築をするだけなので、設計図が間違っていなければ、同じ設計図から必ず同じコンテナが作られる。  
  これまでの環境構築は人の手で行われていたので、ミスが起きるなどの問題が起きてしまっていた。  
- アプリ実行環境の品質UP  
  開発言語やWebサーバーのバージョンと実際にインターネット上に公開しているサーバーは微妙に違う。  
  そのため、同じようなものをインストールして同じようなものを作ろうと努力しても、それができない場合もある（！）  
  Dockerを使うと、同じ設計図をいろいろな環境で使いまわすことができるため、Dockerの設計図があれば、OS、PCスペック、サーバーのスペックやOSは関係なくなる。  
  DockerがハードウェアやOSの差異を吸収してくれるので、アプリ開発の環境の品質が上がり、環境依存のエラーが起こらなくなる。  
- 自動化ソフトとの相性  
  Dockerを使うと、テストや本番環境へのファイルのコンパイルやデプロイ（本番環境へのデータのアップロード）の自動化（[CI/CDパイプライン](https://www.ashisuto.co.jp/devops-portal/cat05/cicd.html)）がききやすくなる。  
  [Jenkins](https://e-words.jp/w/Jenkins.html)や[CircleCI](https://freelance.shiftinc.jp/column/circleci)というCI/CDツールが有名。  
  これらのツールを使うことで、人がやっていた面倒な作業を自動化できる。

# コンテナについて  
Dockerはコンテナを管理するためのツール  
- そもそもコンテナって？  
  サーバー上に隔離されたアプリ空間を作れる技術のこと。  
  サーバーの中にパッケージ化されたソフトがいくつもならぶような構造をつくれるのがコンテナ。  
  基本的に1コンテナに1ソフト
- 仮想環境とDockerの違い  
  - 仮想環境  
  仮想環境はパソコンの中にパソコンを作る技術。元のパソコンがホストOS、パソコンのなかに作ったパソコンがゲストOS。  
  隔離された環境を作るために必要だった。  
  本番環境をインターネット上に公開するサーバーはほぼLINUXなので、Windowsで開発してLINUXに持っていくと、環境の違いから思わぬ不具合につながったり、そもそもWindowsだとサーバーが建てられなかったりした。  
  VirtualBoxなどのソフトを使ってWindowsのなかにLINUXのサーバーを建てることで、WindowsでもLINUXのアプリ開発ができるようになる。  
  クラウド上の大きなサーバーを複数に分割するような使い方をするときは、小さなサーバーをいくつか立ち上げて仮想環境を使って区切りをつけていた。  

|  | Docker | 仮想環境 |
| ---- | ---- | ---- |
| 存在場所 | メモリ上 | ディスク上 |
| ゲストOS | 存在しない | ホストOSとゲストOSに分かれる |
| データ管理 | 一時保存 | 常に保存 |
| コード化 | Dockerfileで可能 | 不可 |

DockerはLINUXサーバー上に直接各ソフトウェアのコンテナが立ち上がるイメージ。
メモリ上にいるので、アプリを開いているような感覚。
また、インフラがコード化できるので、インフラの構成はファイルを見れば一発で理解できる。
仮想環境はデータがディスクにあるので、常にデータが保存されている。


# インフラのコード化  
サーバーは最初はまっさらで、ここで`sudo install php`のような直接ソフトをインストールしていくコマンドを打っていくのがインフラ構築だった。  
しかし、これでは書いたコードをメモしておくくらいでしかインフラの状況を把握できなかった。  
そのため、常に一定のサーバーの状態のものをいくつも作るのは難しかった。  
これを、***Dockerfile***という技術で、手動で作っていたサーバーをすべてコード化して定義することができるようになった。  
Dockerfileがインフラの設計図になり、同じ設計図からは必ず同じコンテナが生成されるので、同じ設計図を使えば誰もが同じサーバーを作れるようになった。
しかも、コードだからテキストファイルであるため、受け渡しも簡単に行える。
これがDockerを使用する大きなメリット。
Dockerfileにはサーバーで実行するコードが定義されていて、設定を自動で行ってくれる。
であるため、設計図が同じなら必ず同じサーバーになる。  
インフラの知識のないエンジニアでも簡単にサーバーが立てられるため、時短にもなる。  
また、人の手が介在しないため、必ず同じものができることから、そもそもミスが起こらなかったり、ちょっとしたサーバートラブルにも対応しやすい。  
インフラをコードで定義してコード化することを  
***Infrastructure As a Code***  
という。

# DockerfileとDockerイメージ

- dockerfile  
  dockerイメージを言語化したもの。
- dockerイメージ  
  dockerコンテナの設計図
- dockerコンテナ  
  実際にwebサーバーやデータベースや言語などの一つのプロセスを入れる箱

build（ `docker compose build`のことでいいのかな）を行うことによって、dockerfileに書かれた内容が実行される。  
例えば、サーバーのインストールコマンドや設定ファイルの変更などの命令が進んでDockerイメージになる。  
一層一層がLINUXコマンドのイメージレイヤー[^1]を持っているDockerイメージが出来上がる。 
`docker run`というコマンドを打つとDockerイメージがDockerコンテナになる。  
これで、実際に動作さっせるコンテナとして実行ができるようになる。  
Dockerイメージは、クラウド上のDocker hubからダウンロードする方法もある。  

# Dockerイメージの構造としくみ

Dockerイメージはレイヤー構造になっていて、一番下のレイヤーはLINUXのベースレイヤーといわれるOSのイメージ。  
その上に、一個一個インストールコマンドを乗せていくイメージレイヤーがあり、これがまとまったものがDockerイメージ。  
一番下のレイヤーは必ずLINUXのUbuntu等いずれかの種類のOSになっている。  

普通にwebサーバーをインストールするとしたら、その上に`sudo yum update y`のような形でパッケージのアップデートをして、それが終わった後に`sudo yum install http`のようなコマンドを打って、Apacheをインストールしていく。  
（これはDockerを使わないときの話？）  
これをコンテナ化するときは一つずつレイヤー構造でLINUXコマンドをのせていく。  
下から並んでいったものを順番に実行されたものがDockerイメージになる。  
`docker run`コマンドを使うと、レイヤー構造をもったものがそのままコンテナになる。  

Dockerイメージはコンテナのひな型。  
それがパッケージ化されているので、みんながDLできて、同じイメージからは同じDockerコンテナが生まれる。  

# Dockerイメージのタグについて

- タグについて  
  タグは**必ず指定する**  
  `イメージ名:タグ名`で指定。  
  ubuntuのver18.04を指定するときは`ubuntu:18.04`。  
  タグを指定しない場合はlatest（最新）になる。  
  
タグはDockerイメージのバージョンを指定するためのもので、タグを指定しない場合は最新バージョンが入ってきてしまう。  
そうなると、トラブルにつながるので絶対にタグを指定する。  
なぜトラブルが起こるかというと、時間がたつと新しいバージョンがでてきて、それが最新バージョンになってしまい、全員が同じ統一したコンテナを使えなくなってしまうから。  
実行する時期によってコンテナイメージのバージョンが変わってしまう。これが思わぬミスにつながってしまう。  
例えばubuntuの最新verが22.0.～だったとして、来年も同じバージョンとは限らない。  
（教材の最終更新日は2024.2~だけど、2024.10現在のubuntuの最新verは24.04みたい？こんな感じに変わると出来上がるコンテナも変わってしまう）  

いろんなDockerイメージが共有されている[Docker Hub](https://hub.docker.com/)  
ここでDockerイメージをDLするためのコマンドがわかる

[![Image from Gyazo](https://i.gyazo.com/0765a48476935a5920bf9376e15503ca.png)](https://gyazo.com/0765a48476935a5920bf9376e15503ca)

# コンテナによるアプリケーション環境の構築  
コンテナは隔離された空間で、基本的に1コンテナにつき1プロセスとなっている。  
ウェブサーバー、アプリケーションサーバー、データベースサーバーのそれぞれが、隔離された空間にいる。  
隔離された空間のままでは、お互いの通信ができないので、サーバーっぽいアプリケーションのようなふるまいはできないが、[リンクオプション](https://docs.docker.jp/engine/userguide/networking/default_network/dockerlinks.html)を使うことでそれぞれのコンテナ同士の通信ができるようになる。  
例えば、リクエストがNGINXにきて、NGINXに来た処理をPHPで処理、PHPがデータが必要と判断した時はMySQLデータベースにデータを取りに行って、リクエストしてくれた相手に返す。  
...というような感じで、コンテナ間で連携して、普通のサーバーに各ソフトをインストールさせた時と同じ動きができるようになる。  
しかし、複数のコンテナの管理が大変になってしまう。これを解決するのが`docker compose`。  
なお、[Dockerドキュメント](https://docs.docker.jp/engine/userguide/networking/default_network/dockerlinks.html)によると  
> Docker の `--link` フラグは過去の機能です。 そのうちに削除されるかもしれません。 この機能を確実に必要としているのでなければ `--link` を使わず、2 つのコンテナ間の通信を実現するユーザ定義のネットワークを利用することをお勧めします。 `--link` に存在していて、ユーザ定義のネットワークにない機能は、コンテナ間で環境変数を共有できる機能です。 ただしボリュームのような別の機能を使えば、コンテナ間での環境変数の共有は、より制御しやすく利用できます。

...とのこと。

# コンテナボリューム

Dockerで一番迷う部分がボリュームの永続化。  
コンテナ内のボリュームは消えてしまうので、データベースなどの永続データには使えない。  
仮想環境だとディスクの上にいるので、データはディスクに書き込まれるため、永続化は常にされているが、Dockerコンテナはメモリ上にいるので、コンテナが削除されてしまうとコンテナ内のボリュームも一緒に削除されてしまう。  
ボリューム共有でコンテナでも永続データベースが作れる。  
コンテナを消すとデータベースも消えてしまうが、ホストとボリュームの共有を行うことで、データを永続化できる。  
ホストのディレクトリとコンテナのディレクトリを共有するやり方があり、共有するとデータベースに書き込みがあったときにホスト側のディスクにも書き込まれるようになる。  
コンテナが壊れて新しいコンテナをDockerイメージから立ち上げなおしても、ホスト側のディレクトリと共有しておくことで、ホスト側の永続データをまた使うことができる。

# 本番環境でのデータベース

本番環境では、ローカルとは違って大量のアクセスが来ることが予想されていたり、サーバーの調子が悪くなることもあるため、複数のサーバーに分散させて処理を実行することで、トラブル時になるべくサービスを止めないようにしている。  
複数のサーバーに分散させることで、内1台のサーバーが落ちても残りのサーバーでアクセスをさばけるので、サービスは停止しない。  
ただ、こうした複数サーバーを使用する本番環境でデータベースコンテナを使用するといろいろと問題が起きる。  
サーバー一個一個のボリュームと共有してしまうと、サーバーによってデータが異なってしまう。  
本番環境ではそうならないように設計するのが基本的な考え方。  
- データベースはコンテナ化しないで、[Amazon Aurora](https://aws.amazon.com/jp/rds/aurora/)のような処理の速いデータベース1個に任せてしまう。
- データベースはコンテナ化するけど、クラウドの高速なSSDに集める

などのやり方がある。

[^1]:イメージを構成する読み込み専用のレイヤのこと。dockerイメージはこれが層になって集まっている。参考：[Dockerfileを理解して書きたくてレイヤ構造を拝んできた忘備録](https://qiita.com/marumeru/items/5b9d19508fa649d060a7)
