function add (a, b) {
  return a + b;
}
add(3, 4);
console.log(add);
/*ƒ add (a, b) {
  return a + b;
}
オブジェクトだけど、chromeがわかりやすく関数っぽく表示させているだけ。
Firefoxだと
function add(a, b)
  arguments: null
  caller: null
  length: 2
  name: "add"
とオブジェクトのように表示される。*/
/*関数はオブジェクトにすぎない。
関数宣言はaddという変数を内部的に用意して、その変数にオブジェクトを代入しているだけ
let add = {
}
こういうことらしい。*/
console.dir(add);
//これでFirefoxみたいにちゃんとオブジェクトとして表示できる。
console.log(add.name)
console.log(add.length)
//オブジェクトなのでこうしてとりだせる。
/*オブジェクトから関数を作ることはできない。
オブジェクトが関数になるための条件であるプロパティには、内部的に作られたプロパティがある。
この内部的に作られたプロパティは、開発者がアクセスすることはできない。変更することもできない。
JSエンジンが内部的に持っている、誰も見ることのできないプロパティをオブジェクトが持つことによってのみ、オブジェクトは関数になれる。
なので、自力でオブジェクトから関数を作ることはできない。*/

let sayHi = function hi() {
  return 'hi';
}
console.log(sayHi());
//関数式
/*関数の書き方を式が必要なところで書いたら関数式というものになる。
関数宣言はaddという変数を作り出すけど、関数式はhiという変数は作っていない。
なので、hiを呼び出そうとしても未定義エラーになる。
なので、関数名を入れなくてもいい。
let sayHi = function () {}
これでもいい。
関数名を書いた式を名前付き関数式、名前がない関数式を無名関数式という。
関数宣言はJSのシステム上どこにいても一番上に巻き上げられるが、関数式を関数式の前によびだそうとすると、
変数未定義になってしまう。
関数式の呼び出しをするときは、必ず関数式が呼び出しより前になければならない。
関数宣言はどこでも使える。パッと見たときに関数だとわかりやすいし、目立つ。
関数式は、関数式の呼び出し式をみたら、必ずその上に関数式の定義が書いてある。
どちらにもメリット、デメリットがあるが、統一したほうがいい。*/

const person = {
  name: 'Rita',
  sayHi: function () {
    return 'hi';
  },
};
console.log(person.sayHi());
// メソッド
/*
オブジェクトのkey、valueの中にある関数をメソッドという。
keyとvalueのセットをプロパティという。
valueの関数がメソッド。
返り値がオブジェクトだった場合、console.log(person.sayHi().key);のように直接つなげて出力できる。
メソッドもつなげることができる。
*/

arrow = (name = 'User') => {
  return `Hi ${name}!`;
}
console.log(arrow('Rita'));
// アロー関数
/*
無名関数の置き換え。無名関数と同じ意味になる。
functionを使わずに関数をかける。
無名関数と違って、名前付き関数式みたいなものはできない。
関数宣言のようなこともできない。
たった一つの処理だけを書くときは、returnも{}もなくていい。
(name) => `Hi ${name}!`でreturnになる。
パラメーターが一個だけの場合、()を省略できる。
name => `Hi ${name}!`
{}から始まった場合はオブジェクトではなくアロー関数のキーワードの{}だと考えてしまうので、
オブジェクトを使うことはできない。
({})にすると、オブジェクトを使うことができる。
*/
// デフォルトパラメータ
/*
パラメータになんの引数も渡されなかったときにデフォルトの値を設定しておく。
(name = 'User')で、引数が渡されなかったときにUserが表示される。
falsyは値として認識するが、undefinedのみ引数が渡されなかったと認識する。
デフォルトパラメータを使う場合は、()を省略することはできない。
*/

let sum = (...nums) => {
  console.log(nums);
}
console.log(sum(1, 2, 5, 7, 9, 1))
// レストパラメータ
/*
無限数の引数を受け取ることができる。
(6) [1, 2, 5, 7, 9, 1]みたいに受け取ってる。
*/

let subtract =  (a, b, callback) => {
  let result = a - b;
  callback(result); // 引数で渡された関数の処理をする
};
subtract(10, 3, function showResult(result) {
  console.log(chocolate);
  console.log(result);
});
// コールバック関数
/*
関数はオブジェクトなので、引数に関数を渡せる。この関数をコールバック関数という。
引数の関数がcallbackの中に入り、関数subtractの中で処理をする。
名前付き関数式を渡すと、エラーが出たときに関数名を出してくれるのでどこでエラーが起こっているかわかりやすい。
ブラウザが関数オブジェクトのnameプロパティをみて、エラー文に表示する関数名を決めている。
無名関数を変数に代入すると、変数名がnameプロパティになる。
*/