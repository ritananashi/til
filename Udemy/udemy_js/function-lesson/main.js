function add (a, b) {
  return a + b;
}
add(3, 4);
console.log(add);
/*ƒ add (a, b) {
  return a + b;
}
オブジェクトだけど、chromeがわかりやすく関数っぽく表示させているだけ。
Firefoxだと
function add(a, b)
  arguments: null
  caller: null
  length: 2
  name: "add"
とオブジェクトのように表示される。*/
/*関数はオブジェクトにすぎない。
関数宣言はaddという変数を内部的に用意して、その変数にオブジェクトを代入しているだけ
let add = {
}
こういうことらしい。*/
console.dir(add);
//これでFirefoxみたいにちゃんとオブジェクトとして表示できる。
console.log(add.name)
console.log(add.length)
//オブジェクトなのでこうしてとりだせる。
/*オブジェクトから関数を作ることはできない。
オブジェクトが関数になるための条件であるプロパティには、内部的に作られたプロパティがある。
この内部的に作られたプロパティは、開発者がアクセスすることはできない。変更することもできない。
JSエンジンが内部的に持っている、誰も見ることのできないプロパティをオブジェクトが持つことによってのみ、オブジェクトは関数になれる。
なので、自力でオブジェクトから関数を作ることはできない。*/

let sayHi = function hi() {
  return 'hi';
}
console.log(sayHi());
//関数式
/*関数の書き方を式が必要なところで書いたら関数式というものになる。
関数宣言はaddという変数を作り出すけど、関数式はhiという変数は作っていない。
なので、hiを呼び出そうとしても未定義エラーになる。
なので、関数名を入れなくてもいい。
let sayHi = function () {}
これでもいい。
関数名を書いた式を名前付き関数式、名前がない関数式を無名関数式という。
関数宣言はJSのシステム上どこにいても一番上に巻き上げられるが、関数式を関数式の前によびだそうとすると、
変数未定義になってしまう。
関数式の呼び出しをするときは、必ず関数式が呼び出しより前になければならない。
関数宣言はどこでも使える。パッと見たときに関数だとわかりやすいし、目立つ。
関数式は、関数式の呼び出し式をみたら、必ずその上に関数式の定義が書いてある。
どちらにもメリット、デメリットがあるが、統一したほうがいい。*/